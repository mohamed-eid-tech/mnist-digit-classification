# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NUfFyK2CXVOy9APKHVQ022RByTMIdvJ8
"""

import torch
import torch.nn as nn
from torchvision import transforms
import numpy as np
import matplotlib.pyplot as plt
import gradio as gr
import os

device = torch.device("cpu")

class MNISTClassifier(nn.Module):
    def __init__(self):
        super(MNISTClassifier, self).__init__()
        self.conv1 = nn.Conv2d(1, 32, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(2, 2)
        self.dropout1 = nn.Dropout(0.25)
        self.fc1 = nn.Linear(64 * 7 * 7, 128)
        self.dropout2 = nn.Dropout(0.5)
        self.fc2 = nn.Linear(128, 10)

    def forward(self, x):
        x = torch.relu(self.conv1(x))
        x = self.pool(x)
        x = torch.relu(self.conv2(x))
        x = self.pool(x)
        x = self.dropout1(x)
        x = torch.flatten(x, 1)
        x = torch.relu(self.fc1(x))
        x = self.dropout2(x)
        x = self.fc2(x)
        return x

print("Creating and loading the model...")
model = MNISTClassifier()
model.load_state_dict(torch.load('best_model.pth', map_location=device))
model.to(device)
model.eval()

def preprocess_image(input_data):
    if isinstance(input_data, dict):
        if 'image' in input_data:
            image = input_data['image']
        elif 'composite' in input_data:
            image = input_data['composite']
        else:
            raise ValueError("Dictionary input missing image data")
    elif isinstance(input_data, np.ndarray):
        image = input_data
    else:
        try:
            image = np.array(input_data)
        except:
            raise ValueError(f"Unsupported input type: {type(input_data)}")

    if image.ndim == 3:
        if image.shape[2] == 4:
            image = image[..., :3]
        image = np.mean(image, axis=2)

    image = 255 - image
    image_tensor = transforms.functional.to_tensor(image).unsqueeze(0)
    image_tensor = transforms.functional.resize(image_tensor, (28, 28))
    image_tensor = transforms.functional.normalize(image_tensor, (0.1307,), (0.3081,))
    return image_tensor

def plot_probabilities(probabilities):
    fig, ax = plt.subplots()
    bars = ax.bar(range(10), probabilities)
    ax.set_xlabel('Digit')
    ax.set_ylabel('Probability')
    ax.set_title('Prediction Probabilities')
    ax.set_xticks(range(10))
    ax.set_ylim(0, 1)
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width() / 2., height, f'{height:.2f}', ha='center', va='bottom')
    plt.tight_layout()
    return fig

def predict_digit(input_data):
    if input_data is None:
        return None, None
    try:
        input_tensor = preprocess_image(input_data).to(device)
        with torch.no_grad():
            output = model(input_tensor)
            probabilities = torch.softmax(output, dim=1).cpu().numpy()[0]
        predicted_digit = int(np.argmax(probabilities))
        prob_plot = plot_probabilities(probabilities)
        plt.close(prob_plot)
        return predicted_digit, prob_plot
    except Exception as e:
        print(f"Error during prediction: {str(e)}")
        return "Error", None

with gr.Blocks(css="footer {display: none !important}") as demo:
    gr.Markdown("# MNIST Digit Recognition")
    gr.Markdown("Draw a digit (0-9) in the box below and see the model's prediction.")
    with gr.Row():
        sketchpad = gr.Sketchpad(label="Draw Digit", image_mode="L", type="numpy", interactive=True)
        with gr.Column():
            label = gr.Label(label="Predicted Digit")
            plot = gr.Plot(label="Prediction Probabilities")
    clear_button = gr.Button("Clear")
    clear_button.click(lambda: (None, None, None), None, [sketchpad, label, plot], queue=False)

    sketchpad.change(fn=predict_digit, inputs=sketchpad, outputs=[label, plot])

demo.queue().launch()
